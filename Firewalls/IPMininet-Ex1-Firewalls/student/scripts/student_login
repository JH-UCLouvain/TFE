#!/bin/python3
# Author : Jeremy Holodiline

from ipmininet.iptopo import IPTopo
from ipmininet.ipnet import IPNet
from ipmininet.cli import IPCLI
from ipmininet.router.config import RouterConfig

import random

def store_feedback(grade, result, feedback):
    STORE = True
    if STORE:
        with open("tmp/student/feedback.txt", "w") as f:
            f.write(str(grade) + "\n")
            f.write(result + "\n")
            f.write(feedback)
    else:
        print(f"Grade : {grade}")
        print(f"Result : {result}")
        print(f"Feedback : {feedback}")

interface_addr = dict()

def generate_IP_addr(interface, version, prefix):
    while True:
        addr = ""
        if version == "v4":
            if prefix != "" and prefix[-1] != ".": prefix += "."
            n_rand = 4 - (len(prefix.split(".")) - 1)
            addr = prefix + ".".join(("%s" % random.randint(0, 255) for _ in range(n_rand)))
            addr = addr.rstrip(".")
        elif version == "v6":
            if prefix != "" and prefix[-1] != ":": prefix += ":"
            n_rand = 8 - (len(prefix.split(":")) - 1)
            for _ in range(n_rand):
                hex_num = ""
                for _ in range(4):
                    hex_num += random.choice(("0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"))
                prefix += hex_num.lstrip("0") + ":"
            addr = prefix
            addr = addr.rstrip(":")
        else: raise ValueError("IP version must be \"v4\" or \"v6\"")
        if addr not in interface_addr.values():
            interface_addr[interface] = addr
            return addr

class MyTopology(IPTopo):

    def build(self, *args, **kwargs):

        h1 = self.addHost("h1")
        h2 = self.addHost("h2")
        h3 = self.addHost("h3")
        h4 = self.addHost("h4")
        r1 = self.addRouter("r1", config=RouterConfig)

        lh1r1 = self.addLink(h1, r1)
        lh1r1[h1].addParams(ip = generate_IP_addr("h1-r1", "v6", "2001:db8:1341:1:") + "/64")
        lh1r1[r1].addParams(ip = generate_IP_addr("r1-h1", "v6", "2001:db8:1341:1:") + "/64")

        lh2r1 = self.addLink(h2, r1)
        lh2r1[h2].addParams(ip = generate_IP_addr("h2-r1", "v6", "2001:db8:1341:2:") + "/64")
        lh2r1[r1].addParams(ip = generate_IP_addr("r1-h2", "v6", "2001:db8:1341:2:") + "/64")

        lh3r1 = self.addLink(h3, r1)
        lh3r1[h3].addParams(ip = generate_IP_addr("h3-r1", "v6", "2001:db8:1341:3:") + "/64")
        lh3r1[r1].addParams(ip = generate_IP_addr("r1-h3", "v6", "2001:db8:1341:3:") + "/64")

        lh4r1 = self.addLink(h4, r1)
        lh4r1[h4].addParams(ip = generate_IP_addr("h4-r1", "v6", "2001:db8:1341:4:") + "/64")
        lh4r1[r1].addParams(ip = generate_IP_addr("r1-h4", "v6", "2001:db8:1341:4:") + "/64")

        super(MyTopology, self).build(*args, **kwargs)

class Test:

    def __init__(self):
        self.n_test = 0
        self.n_success_test = 0
        self.feedback = ""

    def rule_test(self, node, command, expected, failed_msg):
        self.n_test += 1
        output = ""
        try:
            output = net[node].cmd(command)
        except Exception as e:
            self.feedback += f"{node} {command} error : {e}\n"
            return
        if expected in output:
            self.n_success_test += 1
            self.feedback += f"Success\n"
        else:
            self.feedback += f"Failed : {node} {command} : {failed_msg}\n"

    def send_feedback(self):
        grade = 100 if self.n_test == 0 else ((self.n_success_test / self.n_test) * 100)
        result = "success" if grade == 100 else "failed"
        store_feedback(grade, result, self.feedback)

h1_port_to_drop = random.randint(65000, 65100)
h2_port_to_drop = random.randint(65101, 65200)
h3_port_to_remove = random.randint(65201, 65300)
h3_port_to_not_remove = random.randint(65301, 65400)

def get_instructions(cli, args):
    print(f"1) Add the rule to h1 that drops all incoming TCP packets for the {h1_port_to_drop} destination port")
    print(f"2) Add the rule to h2 that drops all outgoing TCP packets for the {h2_port_to_drop} destination port")
    print(f"3) Add the rule to r1 that drops all packets that should have been forwarded from h2 to h3")
    print(f"4) Remove the rule from h3 that drops all outgoing TCP packets for the {h3_port_to_remove} destination port (don't delete any other rule)")
    print(f"5) Add the rule to h4 that drops all incoming packets from h2")

net = IPNet(topo=MyTopology(), allocate_IPs=False)

try:
    net.start()
    net["h3"].cmd(f"ip6tables -A OUTPUT -p tcp --dport {h3_port_to_remove} -j DROP")
    net["h3"].cmd(f"ip6tables -A OUTPUT -p tcp --dport {h3_port_to_not_remove} -j DROP")

    IPCLI.do_instructions = get_instructions

    IPCLI(net)

    test = Test()
    test.rule_test("h2", f"nmap -6 --max-retries 0 -p {h1_port_to_drop} h1", "filtered", f"1) h1 {h1_port_to_drop} port still reachable")
    test.rule_test("h2", f"nmap -6 --max-retries 0 -p {h2_port_to_drop} h1", "filtered", f"2) Outcome from h2 {h2_port_to_drop} port")
    test.rule_test("h2", f"ping -6 -c 1 -W 1 h3", "100% packet loss", f"3) h2 can still reach h3")
    test.rule_test("h3", f"nmap -6 --max-retries 0 -p {h3_port_to_remove} h1", "closed", f"4) Rule about h3 {h3_port_to_remove} port still there")
    test.rule_test("h3", f"nmap -6 --max-retries 0 -p {h3_port_to_not_remove} h1", "filtered", f"4) An other r3 rule has been deleted when it should not have")
    test.rule_test("h2", f"ping -6 -c 1 -W 1 h4", "100% packet loss", f"5) h2 can still reach h4")
    test.send_feedback()

except Exception as e:
    store_feedback(0, "crash", f"Error from the ipmininet script : {e}")

finally:
    net.stop()